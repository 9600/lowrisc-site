+++
Description = ""
date = "2016-05-16T12:00:00+00:00"
title = "A debug session"
parent = "/docs/debug-v0.3/walkthrough/"
prev = "/docs/debug-v0.3/simulation/"
next = "/docs/debug-v0.3/fpga/"
showdisqus = true

+++

Once you have an Open SoC Debug daemon running and it connected to a
target system, you can do debug session. In the following you will
learn the different basic features to interact with the system.

Before you begin, you should be example programs:

    FPGA_DIR=$TOP/vsim make -C $TOP/fpga/bare_metal/examples hello.riscv trace.riscv

### Resetting the system

In the first step we will start the command line interface and reset
the system. With starting the command line interface it automatically
connects to the daemon.

So the steps to connect to the verilated RTL simulation are based on
what you learned before:

 * Start simulation with preloaded software (terminal 1):

        $TOP/vsim/DebugConfig-sim +load=$TOP/fpga/bare_metal/examples/hello.riscv

 * Connect the daemon (terminal 2):

        opensocdebugd tcp

 * Start the command line interface (terminal 3):

        osd-cli

Now you are connected to the debug system and can inspect and control
the system. First, reset the system (`osd> ` is the command line prompt
in the following) and leave the command line again:

    osd> reset
    osd> quit

The command has reset the entire system. If you run the simulation
with vcd output (add `+vcd` to the parameters) you can see how it is
reset. `reset` actually controls the CPU and a different system
reset. With the parameter `-halt` you can keep the CPU reset asserted
and inactive while you load a program to the memory or
configure the debug modules. Running `start` de-asserts the CPU reset
then:

    osd> reset -halt
    osd> [.. some other commands ..]
	osd> start

So now we want to see that in action.

### Capturing UART output

As described before, the UART controller has been replaces with an
emulation module that has the same physical interface, but transports
the characters over the debug infrastructure.

In the command line you can start a terminal that displays the output
by executing `terminal <module id>`. You need to set the module id as
enumerated (here: `2`). This will open an `xterm` and direct output to
it.

So when running the following sequence with the terminal open, you
will see that the cores start and emit the `printf` message after the
third command and after the fourth again:

    osd> reset -halt
    osd> terminal 2
    osd> start
	osd> reset

So, now you can run the programs as before and reset the system
without touching a board, but the real power comes with the other
modules.

### Generate a function trace

To analyze the execution of the program on the core, you can use the
core trace module. It can be configured to log all function calls and
returns from functions to a file. It also logs changes of the
execution mode.

A function trace is generated by activating the core trace module and
giving the ELF currently executed on the core.

    osd> reset -halt
    osd> terminal 2
	osd> ctm log ctm.log path/to/hello.riscv
	osd> start
	osd> quit

Now you can inspect the output file `ctm.log`:

	00033c7c enter init_tls
	00033cac enter memcpy
	00033d48 enter memset
	00033dd1 enter thread_entry
	00033e41 enter main
	00033e67 enter uart_init
	00033f21 enter printf
	00033f9e enter vprintfmt
	0003432e enter syscall
	000343a5 change mode to 3
	0003444c enter handle_trap
	00034616 enter handle_frontend_syscall
	0003469b enter uart_send
	000346f4 enter uart_send
	00034723 enter uart_send
	00034752 enter uart_send
	00034781 enter uart_send
	000347b0 enter uart_send
	000347df enter uart_send
	0003480e enter uart_send
	0003483d enter uart_send
	0003486c enter uart_send
	0003489b enter uart_send
	000348ca enter uart_send
	000348f9 enter uart_send
	00034b9f enter exit
	00034bcd enter syscall
	00034bf4 change mode to 3
	00034c4f enter handle_trap
	00034c92 enter tohost_exit
	Overflow, missed 12 events
	Overflow, missed 13 events
	Overflow, missed 13 events
	Overflow, missed 13 events
	Overflow, missed 13 events
	Overflow, missed 13 events
	Overflow, missed 14 events
	Overflow, missed 14 events
	Overflow, missed 3 events
	Overflow, missed 3 events
	Overflow, missed 3 events
	Overflow, missed 4 events
	Overflow, missed 3 events
	Overflow, missed 3 events
	Overflow, missed 3 events
	Overflow, missed 3 events
	Overflow, missed 4 events
	Overflow, missed 4 events
	Overflow, missed 4 events
	[..]



### Minimally-invasive software debugging

As introduced, lowRISC adds a software trace debugging technique that
is minimally invasive by only adding a few cycles each time called
without stalling the system.

The code `trace.c` from the examples emits four of such events. You
need to load it with the simulation:

    $TOP/vsim/DebugConfig-sim +load=$TOP/fpga/bare_metal/examples/trace.riscv

Then 

### Scripting the command line interface

### Loading the ELF to memory

### Python scripting
